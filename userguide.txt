
  1: Introduction

  Welcome to fruitbox, a customisable, Retro MP3 Jukebox for the 
  Raspberry Pi.


  2: Starting Up

  fruitbox is intended to be run directly from the command line 
  for maximum performance.
  
  See section 'Command Line Options' for startup options.


  3: Operation

  To run fruitbox, from the command line goto the installation 
  directory and type 'sudo ./fruitbox --cfg <file>'.  fruitbox 
  will then look for the configuration (skin) <file>.  See section 
  'Configuration (Skin) Files' for more detail.  After the configuration 
  file has been read, fruitbox will load the song database file 
  (specified in the configuration file).  If the file doesn't exist, 
  a new one will be created (see section 'Database Creation'). 
  When the database has been read, fruitbox will start!
  
  Song pages are moved using the ButtonLeft and ButtonRight keys, 
  and songs are selected using the select keys or cursor keys if 
  in joystick mode.  Once a song is selected, it is added to the 
  play queue.  If no song is playing, the song at the top of the 
  play queue is 'loaded', played, and then 'unloaded'.
  
  Control inputs (buttons) can be re-defined...fruitbox will look 
  for a 'fruitbox.btn' file in the same directory as it is run 
  from (unless an alternative button mapping file is defined using 
  the '--button-map' command line option.  If it finds one, it 
  will read the file and re-map one or more of the input control 
  buttons as specified in the mapping file.


  4: Command Line Options

  fruitbox takes the following command line parameters.


  4.1: --help

    Show basic help and version information.


  4.2: --cfg <filename>           

    This option determines which configuration file (skin) is used.


  4.3: --database <filename>      

    Use the specified database instead of the one specified in the 
    skin


  4.4: --music-path <filepath>    

    Use the specified music path instead of the one specified in 
    the skin.  Only used when the database file doesn't exist (as 
    specified on the command line or skin config file).  Note that 
    the --music-path option can be specified multiple times if the 
    user wishes to construct the database from multiple sources.


  4.5: --user-guide               

    Create this user-guide to file "userguide.txt" (but I guess you 
    already worked that one out...)


  4.6: --debug-song-nums          

    Show select code alongside song entries


  4.7: --no-database-update       

    Normally fruitbox will update the database if it has a modification 
    time earler than the contents of any of the MusicPath directories.This 
    option disables this check, so it is up to the user to delete 
    the database file in order for it to be regenerated.


  4.8: --config-buttons           

    This option allows the user to interactively change the input 
    control button mappings, and creates the button mapping file 
    specified by the --button-map command line option (or 'fruitbox.btn' 
    if not specified)


  4.9: --calibrate-touch          

    Used in conjunction with '--config-buttons' , this allows the 
    user to interactively specify the touch-min and touch-max values 
    rather than through the command line options.  It will also write 
    these values to the button mapping file for future use.


  4.10: --test-buttons             

    This option allows button codes to be checked without creating 
    a button mapping file.


  4.11: --load-playlist <filename> 

    Loads a playlist file and populates the play queue with the songs 
    in it; fruitbox will begin playing the songs after it has playing 
    up.


  4.12: --save-playlist <filename> 

    When fruitbox exits (by the user pressing the 'Quit' button), 
    this option saves the contents of the play queue (and currently 
    playing song) to the specified file.  This can subsequently be 
    loaded back into fruitbox using the '--load-playlist' command 
    line argument.  The playlist file contains a list of song filenames 
    which can easily be edited by hand to modify the playlist as 
    required.


  4.13: --choose-cfg <filename>    

    This option allows the user to choose a configuration file (skin) 
    from a menu when fruitbox starts up, rather than specifying it 
    using the '--cfg' command line option.  The <file> parameter, 
    should contain a list of cfg files to choose from.  Each entry 
    takes the form 'File = <file>' (path and name of a skin's cfg 
    file).
    
    fruitbox will allow the user to cycle through the list of files 
    using the ButtonLeft and ButtonRight keys.  Any other button 
    will select the skin.  The 'SkinName' and 'SkinDescription' values 
    in the skin cfg files will be used to display information about 
    each skin. A preview of the skin is shown if a screenshot file 
    exists (by default, 'screenshot.jpg' in the same directory as 
    the cfg file, or the name of the 'Screenshot' parameter value 
    in the skin configuration file).  Note that screenshot files 
    can be generated with the '--screenshot' command line option.


  4.14: --screenshot               

    Save a screenshot of the skin, then quit without running.  The 
    screenshot will be written to 'screenshot.jpg' in the skin directory 
    by default or the value of the 'Screenshot' parameter in the 
    skin configuration file.  This option should be used in conjunction 
    with the '--cfg' or '--choose-cfg' command line options.


  4.15: --no-scale                 

    Normally fruitbox will scale (resize) the skin to the display, 
    so no matter what it's size, it will always fit exactly.  This 
    option turns off the scaling so the skin will be shown at its 
    original size (useful for debugging skin designs).  The skin 
    will be centered on the display.  If the skin is smaller than 
    the display then the skin will be surrounded by a black border, 
    but if the skin is larger than the display, the outer edges of 
    the skin will not be visible.


  4.16: --button-map <filename>    

    Name of button mapping file (defaults to 'fruitbox.btn' if not 
    specified)


  5: Configuration (Skin) Files

  Configuration files (skins) define the look and feel of fruitbox. 
  A configuration file is a human-readable text file containing 
  a list of parameters and their values.  Parameters are grouped 
  into sections, where each section is defined by its name enclosed 
  in square brackets, followed by the parameter list for that section. 
  The order of sections is not important except when the section 
  refers to a display object, in which case the order of the sections 
  determines the render order on the display.
  
  A parameter is defined by specifying its name, followed by its 
  parameter value(s).  The parameter name and values can be separated 
  by whitespace, = or :.  Parameter values can be strings, numeric 
  decimal values, or boolean values (true, false, enable, disable, 
  on, off, yes, no, 0, 1).  Comments can be included in the configuration 
  file by prefixing any comment text with the '#' character.
  
  The following list shows all the possible parameters for each 
  section.  If a parameter is not specified in the configuration 
  file, fruitbox will use a default value.
  
  Note that entries marked with a '*' means that these groups / 
  parameters can be defined multiple times.
  Note: filenames for 'Database' and 'MusicPath' parameters have 
  file paths relative to the directory fruitbox was run from, whereas 
  filenames for all other parameters (sound files, bitmap files, 
  status text files, font files) have paths which are relative 
  to the directory the configuration file itself is in.  This allows 
  configuration files and their associated content files to be 
  kept together, but easily share common MusicPath(s) and Database 
  files with other skins.


  ** Recognised AutoGenre values are...

                           Blues                  Classic Rock                       Country                         Dance
                           Disco                          Funk                        Grunge                       Hip-Hop
                            Jazz                         Metal                       New Age                        Oldies
                           Other                           Pop                           R&B                           Rap
                          Reggae                          Rock                        Techno                    Industrial
                     Alternative                           Ska                   Death Metal                        Pranks
                      Soundtrack                   Euro-Techno                       Ambient                      Trip-Hop
                           Vocal                     Jazz+Funk                        Fusion                        Trance
                       Classical                  Instrumental                          Acid                         House
                            Game                    Sound Clip                        Gospel                         Noise
                      AlternRock                          Bass                          Soul                          Punk
                           Space                    Meditative              Instrumental Pop             Instrumental Rock
                          Ethnic                        Gothic                      Darkwave             Techno-Industrial
                      Electronic                      Pop-Folk                     Eurodance                         Dream
                   Southern Rock                        Comedy                          Cult                   Gangsta Rap
                          Top 40                 Christian Rap                    Pop / Funk                        Jungle
                 Native American                       Cabaret                      New Wave                   Psychedelic
                            Rave                     Showtunes                       Trailer                         Lo-Fi
                          Tribal                     Acid Punk                     Acid Jazz                         Polka
                           Retro                       Musical                   Rock & Roll                     Hard Rock
                            Folk                     Folk-Rock                 National Folk                         Swing
                     Fast Fusion                         Bebob                         Latin                       Revival
                          Celtic                     Bluegrass                    Avantgarde                   Gothic Rock
                Progressive Rock              Psychedelic Rock                Symphonic Rock                     Slow Rock
                        Big Band                        Chorus                Easy Listening                      Acoustic
                          Humour                        Speech                       Chanson                         Opera
                   Chamber Music                        Sonata                      Symphony                    Booty Bass
                          Primus                   Porn Groove                        Satire                      Slow Jam
                            Club                         Tango                         Samba                      Folklore
                          Ballad                  Power Ballad                 Rhythmic Soul                     Freestyle
                            Duet                     Punk Rock                     Drum Solo                    A Cappella
                      Euro-House                    Dance Hall                           Goa                   Drum & Bass
                      Club-House                      Hardcore                        Terror                         Indie
                         BritPop                     Negerpunk                    Polsk Punk                          Beat
           Christian Gangsta Rap                   Heavy Metal                   Black Metal                     Crossover
          Contemporary Christian                Christian Rock                      Merengue                         Salsa
                    Thrash Metal                         Anime                          JPop                      Synthpop
                        Abstract                      Art Rock                       Baroque                       Bhangra
                        Big Beat                     Breakbeat                      Chillout                     Downtempo
                             Dub                           EBM                      Eclectic                       Electro
                    Electroclash                           Emo                  Experimental                        Garage
                          Global                           IDM                      Illbient                 Industro-Goth
                        Jam Band                     Krautrock                     Leftfield                        Lounge
                       Math Rock                  New Romantic                     Nu-Breakz                     Post-Punk
                       Post-Rock                     Psytrance                      Shoegaze                    Space Rock
                       Trop Rock                   World Music                  Neoclassical                     Audiobook
                   Audio Theatre           Neue Deutsche Welle                       Podcast                    Indie Rock
                          G-Funk                       Dubstep                   Garage Rock                      Psybient
  
  Note that you can also define your own Genres and fruitbox will recognise these if the 'AutoGenre' 
  field matches the name in the MP3 (ID3v2) genre tag.

  fruitbox will make every effort to choose a song from the specified AutoGenre, but is constrained
  by the song history and number of songs available to choose from.  If it cannot choose a song
  in a reasonable time, it will play any song.


  5.1: Time Values

    Several skin parameters are specified in terms of time.  The 
    time value refers to the number of video frame ticks.  So for 
    example at 60Hz, a time value of 120 equals 2 seconds.  When 
    starting up, fruitbox will detect the video display and print 
    out the frame rate (along with the resolution).


  5.2: Status Bitmaps

    There are two ways of specifying bitmaps in status objects...
    
    Using one or more 'Bitmap' parameters.  This preloads the bitmaps 
    on startup, so the number is limited by the GPU memory, but allows 
    for fast switching for full-frame rate animation.
    
    Alternatively, the 'BitmapDirectory' can be used.  This specifies 
    a location on the file system in which image files are stored 
    (.bmp, .jpg, .png).  fruitbox only loads these into GPU memory 
    when needed, so is slower, but there is no limit on the number 
    of image files.  This is more suitable for use in slide-show 
    displays for example.


  5.3: Status Videos

    Status boxes can be used to display either video clips or music 
    videos.  If the Video parameter is specified in the [status] 
    object, any reference to VIDEO in the status Contents file variables 
    (i.e. $DRAW_VIDEO) will refer to the video clip specified by 
    the Video parameter.  If the Video parameter is not specified, 
    any VIDEO $variables will refer to the currently playing song 
    (if it's a video file).
    
    The only supported format is .ogv (Vorbis + Theora). Any video 
    format can be converted to this format using for example ffmpeg 
    with the following options for specifying the video bitrate and 
    video picture size for better quality...
    
     ffmpeg -i MyVideo.mp4 -b:v 2M -vf scale=640x480 MyVideo.ogv
    
    Since the video decoding process is quite CPU intensive, it is 
    recommended that a Quad core Pi is used (Model 2 or 3) with a 
    good PSU (at least 2 Amps) when running fruitbox and skins with 
    video content, and the display resolution is kept low (less than 
    1024x768).


  5.4: Fonts and Text

    The configuration file [font] section(s) allow multiple fonts 
    of different sizes to be loaded and used by different display 
    elements.  This removes the need for each text definition to 
    load it's own font, instead referencing a specific font type 
    and size from the 'font pool'.
    
    Text definitions ([general] ArtistText, [general] SongText, [general] 
    PairedSongText, [general] ExtraText and [status] Text) parameters 
    have the following arguments...
    
    <font> <colour> <alignment> <capitalise> <condense> <quoted> 
    <offset> <max_width>
    
          font : number of font from 'font pool' (0..)
                 note that the fonts in the pool are numbered in
                 the order in which they are defined in the
                 configuration file
        colour : red green blue alpha (0..255)
                 (alpha : 0 completely transparent
                 through to 255 completely opaque)
     alignment : 'Left', 'Centre' or 'Right'
    capitalise : 'Yes' or 'No'
      condense : 'Yes' (wide text is horizontally squashed to fit
                 within max_width),
                 'No' no squashing is done
        quoted : 'Yes' (text is wrapped within double-quotes),
                 'No' text is unmodified
        offset : x y (text position is shifted by these amounts
                 in pixels)
     max_width : The maximum width of the text.  If the text is
                 wider than this, then it will be shrunk to the
                 maximum width (if the 'condense' option is 'Yes')


  5.5: Coin Mode

    fruitbox can support upto four coin buttons.  Each coin button 
    has it's own 'PlaysPerCoin' value, so that fruitbox can mimic 
    jukeboxes which have multiple coin slots, for different coin 
    denominations.  If all four 'PlaysPerCoin' parameters are zero 
    (or not specified) then fruitbox will operate in free play mode.


  5.6: Joystick Mode

    If a [joystick] object is specified in the skin file, then joystick 
    mode is activated.  This allows a song to be chosen using the 
    ButtonUp, ButtonDown, ButtonLeft and ButtonRight buttons instead 
    of entering the select code.  Pressing ButtonSelect will then 
    add that song to the play queue (AutoSelect mode is disabled 
    when joystick mode is active).
    
    The joystick image specified is positioned in the same place 
    as the song title being selected, and its size is calculated 
    to fit exactly into the region containing the song title.  Specifying 
    the 'Size' parameter in the configuration file allows the size 
    to be set manually, for example if the highlighted bitmap needs 
    to overlap the song title region.  The 'Offset' parameter can 
    then be used to adjust the position of the highlighter precisely 
    around the song title region.


  5.7: Touch Song Mode

    If a [touch song] object is specified in the skin file, then 
    touch song mode is activated (only if a touch screen has been 
    detected).  This option over-rides joystick mode if that has 
    also been defined (using the [joystick] object).
    
    In touch song mode, the user can touch the song title areas themselves 
    to select a song, rather than using select buttons.  Note that 
    the song touch areas default to the page area holding the song 
    name, but their size and position can be adjusted by using the 
    'Size' and 'Offset' [touch song] parameters.  The 'Bitmap' parameter 
    defines an image file which is displayed over the song area when 
    being touched.


  5.8: Random Songs

    fruitbox can play random songs in one of two ways...
     1. The user pressing the 'Random' button
     2. fruitbox selecting a random song in AutoPlay mode
    
    In either case, fruitbox will attempt to prevent songs being 
    repeatedly played by only picking a song if it doesn't appear 
    in it's song play history and current playqueue. The size of 
    the history list can be changed with the 'SongHistoryDepth' configuration 
    parameter.  If this is large and the number of songs in the database 
    is relatively small, then fruitbox may not be able to quickly 
    choose a random song which has not previously been played within 
    the history and current play queue, so will just play a random 
    song anyway even if it already been played recently.


  5.9: Albums / Singles Mode

    Fruitbox has two distinct modes - Albums and Singles, specified 
    by the 'PageMode' parameter.
    
    In Singles mode, each song is individually selectable, and each 
    page displays a number of songs (or pairs of songs), each along 
    with the artist name.  'ArtistText', 'SongText', 'PairedSongText', 
    'PairSongs' and 'SongsPerPage' configuration parameters can be 
    used adjust the appearance of the song details on the pages.
    
    In Albums mode, each page shows the album title, album artist, 
    album cover art, and list of songs in the album (upto the SongsPerPage 
    value).  One selection will add all the songs in the album to 
    the play queue in one go (assuming, in non-freeplay mode, there 
    are sufficient credits).  'AlbumText', 'ArtistText', 'SongText', 
    'PairedSongText', 'AlbumArtSize', 'AlbumArtOffset' and 'SongsPerPage' 
    configuration parameters can be used adjust the appearance of 
    the album details on the pages.  Also note that 'PairedSongDescription' 
    is used to define the contents of the line which is associated 
    with the 'AlbumText' parameter, and all of the 'Paired*' Description 
    values are ignored (as these are only relevant for singles mode 
    song pairs).


  6: Database Creation

  Once fruitbox has read the skin file and found no problems, it 
  will try to load the music database as specified in the skin 
  file.  The database contains details of your music; tagged and 
  pre-formatted to allow fruitbox to use it efficiently.  If the 
  database file doesn't exist, then fruitbox will automatically 
  generate it for you, using one or more 'MusicPath'(s) as specified 
  in the skin file.  Each MusicPath parameter must point to an 
  accessible file directory (for example a directory on the SD 
  card itself or a USB memory drive), which contains MP3 songs 
  (which can be in sub-directories).
  
  Building the database file may take some considerable time if 
  your music library is large, but it only needs to be done once, 
  and subsequent start-ups of fruitbox will be very fast.  If you 
  add or remove music from your library, fruitbox will regenerate 
  it automatically, providing the changes are in the same MusicPath 
  directory.  If not, you will have to manually delete the database 
  filefor frtuibox to re-generate it correctly.  Alternatively, 
  the database file can be edited by hand in a standard text editor 
  if you have small changes to make or are feeling brave!.  This 
  can be useful if you wish to add or remove particular songs, 
  or tweak the song details, without having to re-generate the 
  database from scratch.  Note that the song order in the database 
  file is irrelevant; after fruitbox has read the songs from the 
  database file it will sort them according to the 'SortSongsBy' 
  configuration parameter.
  
  If the database file already exists, then fruitbox will ignore 
  the MusicPath parameter(s) in the skin file.


  7: Screen Layout

  The display is built using a combination of the following objects, 
  as defined in the skin file:
  
  1.       [page] object : a region which contains songs.
                          See pages section for more details.
  2.     [bitmap] object : a region which contains a static bitmap.
                          This can be used for background and
                          foregrounds for example.
  3.     [status] object : a region containing status information.
                          See status box section for more details.
  4.   [joystick] object : a region containing a bitmap controlled
                          by the four cursor keys.
                          See joystick section for more details.
  5. [touch song] object : a region containing a bitmap highlighting
                          a song name when touched.
                          See touch song section for more details.
  
  Note that there is no limit on the number of objects which can 
  be defined.  They are rendered to the display in the order that 
  they are defined in the skin file.


  7.1: Pages

    Pages are the regions in the display which contain the songs. 
    In Singles mode, song titles** are listed vertically, and shown 
    along with the artist name.  If 'PairSongs' is enabled, then 
    the songs are arranged in pairs with the artist name*** shown 
    in between them (i.e. side A/B).  In Albums mode, the page contains 
    details about the album in addition to the song list (see section 
    'Albums / Singles Mode' for more details).
    
    Songs are sorted in the order according to the 'SortSongsBy' 
    configuration parameter.  Songs in each page (in Singles mode), 
    or pages themselves (in Albums mode) are assigned their own unique 
    select code.  The command line option '--debug-song-nums' can 
    be used to make these codes visible; useful when developing skins.
    
    Pages automatically move and update their contents when the ButtonLeft 
    or ButtonRight keys are pressed.  The look and movement of the 
    pages is determined by 'PageMoveStyle' parameter in the skin 
    file, as follows:
    
     PageMoveStyle <speed> <effect> <fade>
    
          <speed>
            1..x = higher number = faster page turn (0 = instant)
          <effect> ...
               0 = swipe horizontally
               1 = swipe vertically
               2 = reveal horizontally
               3 = reveal vertically
               4 = turn horizontally
               5 = turn vertically
               6 = dissolve
           <fade>
             no  = pages don't fade
             yes = pages fade to black
    
    Notes:
    
    ** The 'SongDescription' and 'PairedSongDescription' configuration 
    parameters can be used to modify the text displayed on the song 
    lines of the page(s)  ('PairedSongDescription' is only used if 
    'PairSongs' is not set to false) by setting it to 'SongTitle', 
    'Artist', 'AlbumTitle', 'AlbumArtist', 'Year', 'Genre', 'TrackNumber', 
    'Publisher', 'ISRC', 'Custom', 'PairedSongTitle', 'PairedArtist', 
    'PairedAlbumTitle', 'PairedAlbumArtist', 'PairedYear', 'PairedGenre', 
    'PairedTrackNumber', 'PairedPublisher', 'PairedISRC', 'PairedCustom' 
    or any user string enclosed in double quotes.  Also, if multiple 
    'SongDescription' parameters are specified, then they are joined 
    together to make a single text line.  For example...
     SongDescription = SongTitle
     SongDescription = " ["
     SongDescription = Year
     SongDescription = "]"
    ...will display the text 'Pinball Wizard [1969]' (for example) 
    for the song entries on each page.
    
    *** The 'ArtistDescription' configuration parameter works in 
    the same way as the 'SongDescription' parameter, but affects 
    the artist name text in the page(s) rather than the song title 
    text.


  7.2: Status Boxes

    Status Boxes provide a very flexible way of displaying real-time 
    text-based information, and fixed and animated bitmaps.  Using 
    the 'Output' parameter also allows the status information to 
    be written to an external file to be parsed by external applications*. 
    Examples of status include 'Now Playing' information, 'Coming 
    Up' song list, Select Code, Credits, etc.  Each status box defined 
    should have a 'Contents' file associated with it.  This is a 
    file that contains human readable text which indicates what is 
    drawn in the status box.
    
    As well as fixed text, the user can also specify the following 
    predefined variables, which represent song details and jukebox 
    status, and also enable text and bitmaps to be conditionally 
    drawn under many different circumstances.  The GPIO related predefined 
    variables allow GPIO pins to be driven with high or low values 
    under different fruitbox conditions.
    
    * Note: outputting status to a text file can be done as well 
    as displaying the status on the display, or instead of (to supress 
    the status being rendered to the display, do not define the 'Size' 
    parameter (or set width and/or height to zero).

      $NOW_PLAYING_TITLE
      The name of the song which is currently playing

      $NOW_PLAYING_ARTIST
      The name of the artist of the song which is currently playing

      $NOW_PLAYING_ALBUM
      The name of the album of the song which is currently playing

      $NOW_PLAYING_ALB_ARTIST
      The name of the album artist of the song which is currently playing

      $NOW_PLAYING_TRACK_NUMBER
      The track number of the song which is currently playing

      $NOW_PLAYING_YEAR
      The year of the song which is currently playing

      $NOW_PLAYING_GENRE
      The genre of the song which is currently playing

      $NOW_PLAYING_PUBLISHER
      The publisher of the song which is currently playing

      $NOW_PLAYING_ISRC
      The ISRC of the song which is currently playing

      $NOW_PLAYING_CUSTOM_TAG
      The custom MP3 tag of the song which is currently playing

      $NOW_PLAYING_LENGTH
      The length in mm:ss of the currently playing song

      $NOW_PLAYING_ELAPSED_TIME
      The elapsed time in mm:ss of the currently playing song

      $NOW_PLAYING_TIME_REMAINING
      The remaining time in mm:ss of the currently playing song

      $NOW_PLAYING_ARTWORK
      The cover artwork of the currently playing song.  The artwork 
      will occupy the entire status box, and is drawn before any text. 
      The actual artwork displayed will depend upon the value of the 
      [general] 'ArtworkMode' configuration setting.

      $COMING_UP_NUM_SONGS
      The number of songs coming up in the play queue

      $COMING_UP_TOTAL_TIME
      The total play time in hh:mm:ss of the songs in the play queue

      $COMING_UP_TITLE
      The title of a song in the play queue.  Each time this reserved 
      word is used, it refers to the next song after the last one referenced

      $COMING_UP_ARTIST
      The artist name of a song in the play queue.  Each time this 
      reserved word is used, it refers to the next song after the last 
      one referenced

      $COMING_UP_ALBUM
      The album name of a song in the play queue.  Each time this reserved 
      word is used, it refers to the next song after the last one referenced

      $COMING_UP_ALB_ARTIST
      The album artist name of a song in the play queue.  Each time 
      this reserved word is used, it refers to the next song after 
      the last one referenced

      $COMING_UP_TRACK_NUMBER
      The track number a song in the play queue.  Each time this reserved 
      word is used, it refers to the next song after the last one referenced

      $COMING_UP_YEAR
      The year of a song in the play queue.  Each time this reserved 
      word is used, it refers to the next song after the last one referenced

      $COMING_UP_GENRE
      The genre of a song in the play queue.  Each time this reserved 
      word is used, it refers to the next song after the last one referenced

      $COMING_UP_PUBLISHER
      The publisher of a song in the play queue.  Each time this reserved 
      word is used, it refers to the next song after the last one referenced

      $COMING_UP_ISRC
      The ISRC of a song in the play queue.  Each time this reserved 
      word is used, it refers to the next song after the last one referenced

      $COMING_UP_CUSTOM_TAG
      The custom MP3 tag of a song in the play queue.  Each time this 
      reserved word is used, it refers to the next song after the last 
      one referenced

      $COMING_UP_LENGTH
      The length in mm:ss of a song in the play queue.  Each time this 
      reserved word is used, it refers to the next song after the last 
      one referenced

      $LAST_PLAYED_TITLE
      The name of the song which was last played

      $LAST_PLAYED_ARTIST
      The name of the artist of the song which was last played

      $LAST_PLAYED_ALBUM
      The name of the album of the song which was last played

      $LAST_PLAYED_ALB_ARTIST
      The name of the album artist of the song which was last played

      $LAST_PLAYED_TRACK_NUMBER
      The track number of the song which was last played

      $LAST_PLAYED_YEAR
      The year of the song which was last played

      $LAST_PLAYED_GENRE
      The genre of the song which was last played

      $LAST_PLAYED_PUBLISHER
      The publisher of the song which was last played

      $LAST_PLAYED_ISRC
      The ISRC of the song which was last played

      $LAST_PLAYED_CUSTOM_TAG
      The custom MP3 tag of the song which was last played

      $LAST_PLAYED_LENGTH
      The length in mm:ss of the song which was last played

      $CREDITS
      The number of credits

      $AUTO_GENRE
      The name of the current AutoGenre that AutoPlay will select a 
      random song from

      $PLAYS_PER_COIN1
      The number of plays per coin

      $PLAYS_PER_COIN2
      The number of plays per coin

      $PLAYS_PER_COIN3
      The number of plays per coin

      $PLAYS_PER_COIN4
      The number of plays per coin

      $VOLUME
      The song volume

      $SELECT_CODE
      The select code

      $NUM_SONGS
      The total number of songs in the database

      $NUM_PAGES
      The total number of pages in the jukebox

      $FIRST_VISIBLE_PAGE
      The number of the first page visible on the display

      $LAST_VISIBLE_PAGE
      The number of the last page visible on the display

      $SET_GPIO_00_HI
      Sets the specified GPIO output high

      $SET_GPIO_00_LO
      Sets the specified GPIO output low

      $SET_GPIO_01_HI
      Sets the specified GPIO output high

      $SET_GPIO_01_LO
      Sets the specified GPIO output low

      $SET_GPIO_02_HI
      Sets the specified GPIO output high

      $SET_GPIO_02_LO
      Sets the specified GPIO output low

      $SET_GPIO_03_HI
      Sets the specified GPIO output high

      $SET_GPIO_03_LO
      Sets the specified GPIO output low

      $SET_GPIO_04_HI
      Sets the specified GPIO output high

      $SET_GPIO_04_LO
      Sets the specified GPIO output low

      $SET_GPIO_05_HI
      Sets the specified GPIO output high

      $SET_GPIO_05_LO
      Sets the specified GPIO output low

      $SET_GPIO_06_HI
      Sets the specified GPIO output high

      $SET_GPIO_06_LO
      Sets the specified GPIO output low

      $SET_GPIO_07_HI
      Sets the specified GPIO output high

      $SET_GPIO_07_LO
      Sets the specified GPIO output low

      $SET_GPIO_08_HI
      Sets the specified GPIO output high

      $SET_GPIO_08_LO
      Sets the specified GPIO output low

      $SET_GPIO_09_HI
      Sets the specified GPIO output high

      $SET_GPIO_09_LO
      Sets the specified GPIO output low

      $SET_GPIO_10_HI
      Sets the specified GPIO output high

      $SET_GPIO_10_LO
      Sets the specified GPIO output low

      $SET_GPIO_11_HI
      Sets the specified GPIO output high

      $SET_GPIO_11_LO
      Sets the specified GPIO output low

      $SET_GPIO_12_HI
      Sets the specified GPIO output high

      $SET_GPIO_12_LO
      Sets the specified GPIO output low

      $SET_GPIO_13_HI
      Sets the specified GPIO output high

      $SET_GPIO_13_LO
      Sets the specified GPIO output low

      $SET_GPIO_14_HI
      Sets the specified GPIO output high

      $SET_GPIO_14_LO
      Sets the specified GPIO output low

      $SET_GPIO_15_HI
      Sets the specified GPIO output high

      $SET_GPIO_15_LO
      Sets the specified GPIO output low

      $SET_GPIO_16_HI
      Sets the specified GPIO output high

      $SET_GPIO_16_LO
      Sets the specified GPIO output low

      $SET_GPIO_17_HI
      Sets the specified GPIO output high

      $SET_GPIO_17_LO
      Sets the specified GPIO output low

      $SET_GPIO_18_HI
      Sets the specified GPIO output high

      $SET_GPIO_18_LO
      Sets the specified GPIO output low

      $SET_GPIO_19_HI
      Sets the specified GPIO output high

      $SET_GPIO_19_LO
      Sets the specified GPIO output low

      $SET_GPIO_20_HI
      Sets the specified GPIO output high

      $SET_GPIO_20_LO
      Sets the specified GPIO output low

      $SET_GPIO_21_HI
      Sets the specified GPIO output high

      $SET_GPIO_21_LO
      Sets the specified GPIO output low

      $SET_GPIO_22_HI
      Sets the specified GPIO output high

      $SET_GPIO_22_LO
      Sets the specified GPIO output low

      $SET_GPIO_23_HI
      Sets the specified GPIO output high

      $SET_GPIO_23_LO
      Sets the specified GPIO output low

      $SET_GPIO_24_HI
      Sets the specified GPIO output high

      $SET_GPIO_24_LO
      Sets the specified GPIO output low

      $SET_GPIO_25_HI
      Sets the specified GPIO output high

      $SET_GPIO_25_LO
      Sets the specified GPIO output low

      $SET_GPIO_26_HI
      Sets the specified GPIO output high

      $SET_GPIO_26_LO
      Sets the specified GPIO output low

      $SET_GPIO_27_HI
      Sets the specified GPIO output high

      $SET_GPIO_27_LO
      Sets the specified GPIO output low

      $SET_FLAG_1_HI
      Sets the specified status flag high

      $SET_FLAG_1_LO
      Sets the specified status flag low

      $SET_FLAG_2_HI
      Sets the specified status flag high

      $SET_FLAG_2_LO
      Sets the specified status flag low

      $SET_FLAG_3_HI
      Sets the specified status flag high

      $SET_FLAG_3_LO
      Sets the specified status flag low

      $SET_FLAG_4_HI
      Sets the specified status flag high

      $SET_FLAG_4_LO
      Sets the specified status flag low

      $DRAW_BITMAP
      Draw user defined bitmaps, as specified by the Bitmap parameter. 
      The bitmap will occupy the entire status box, and is drawn after 
      any text.  If multiple bitmaps are defined, they will be drawn 
      in turn, each time the $DRAW_BITMAP keyword is executed.  Bitmaps 
      remain visible until a $UNDRAW_BITMAP command is executed.

      $DRAW_RANDOM_BITMAP
      Draw a random user defined bitmap, chosen from the specified 
      Bitmap parameters.

      $UNDRAW_BITMAP
      Undraw the bitmap

      $DRAW_VIDEO
      Draw the video

      $UNDRAW_VIDEO
      Undraw the video

      $START_VIDEO
      Start video playing

      $STOP_VIDEO
      Stop video playing

      $PAUSE_VIDEO
      Pause video playing

      $UNPAUSE_VIDEO
      Un-pause video playing

      $STOP_TIMER
      Stop the status TimerTick timer

      $START_TIMER
      Start the status TimerTick timer

      $RESET_TIMER
      Reset the status TimerTick timer

      $IF_FREE_PLAY
      Activates the text following it if Free Play mode is enabled

      $IF_NOT_FREE_PLAY
      Activates the text following it if Free Play mode is disabled

      $IF_NO_CREDITS
      Activates the text following it if no credits are available

      $IF_ANY_CREDITS
      Activates the text following it if credits are available

      $IF_SONG_PLAYING
      Activates the text following it if a song is currently playing

      $IF_NOT_SONG_PLAYING
      Activates the text following it if no song is currently playing

      $IF_VIDEO_SONG_PLAYING
      Activates the text following it if the song is currently playing 
      is a video

      $IF_NOT_VIDEO_SONG_PLAYING
      Activates the text following it if the song is currently playing 
      is not a video

      $IF_SONG_LOADING
      Activates the text following it if a song is currently loading

      $IF_NOT_SONG_LOADING
      Activates the text following it if no song is currently loading

      $IF_SONG_UNLOADING
      Activates the text following it if a song is currently unloading

      $IF_NOT_SONG_UNLOADING
      Activates the text following it if no song is currently unloading

      $IF_ANY_COMING_UP
      Activates the text following it if any songs are coming up

      $IF_NONE_COMING_UP
      Activates the text following it if no songs are coming up

      $IF_SONG_COMING_UP
      Activates the text following it if there is another song in the 
      play queue.  This is different to the $IF_ANY_COMING_UP keyword 
      because it refers to the next coming up entry rather than the 
      complete play queue

      $IF_AUTO_PLAY_MODE
      Activates the text following it if Auto Play mode is enabled

      $IF_NOT_AUTO_PLAY_MODE
      Activates the text following it if Auto Play mode is disabled

      $IF_LOOP_MODE
      Activates the text following it if Loop mode is enabled

      $IF_NOT_LOOP_MODE
      Activates the text following it if Loop mode is disabled

      $IF_TIMER_HI
      Activates the text following it if the status timer is high. 
      The value of 'TimerTickPeriod' for the status object in the 
      configuration file determines the rate at which the timer toggles 
      between high and low.  i.e. TimerTickPeriod = 30 means the timer 
      will be high for 30 video frames, then low for 30 video frames, 
      repeating indefinitely

      $IF_TIMER_LO
      Activates the text following it if the status timer is low

      $IF_TIMER_TICK
      Activates the text following it when the status timer ticks (each 
      tick occurs every TimerTickPeriod video frames

      $IF_MUTE
      Activates the text following it when the song volume is muted

      $IF_NOT_MUTE
      Activates the text following it when the song volume is not muted

      $IF_PAGE_MOVING
      Activates the text following it when the song pages are moving

      $IF_NOT_PAGE_MOVING
      Activates the text following it when the song pages are not moving

      $IF_PLAYQUEUE_EMPTY
      Activates the text following it if the play queue is empty
      (includes currently playing song)

      $IF_NOT_PLAYQUEUE_EMPTY
      Activates the text following it if the play queue is not empty
      (includes currently playing song)

      $IF_PLAYQUEUE_FULL
      Activates the text following it if the play queue is full
      (includes currently playing song)

      $IF_NOT_PLAYQUEUE_FULL
      Activates the text following it if the play queue is not full
      (includes currently playing song)

      $IF_STEREO
      Activates the text following it if the current song is stereo

      $IF_NOT_STEREO
      Activates the text following it if the current song is not stereo

      $IF_PAUSED
      Activates the text following it if the current song is paused

      $IF_NOT_PAUSED
      Activates the text following it if the current song is not paused

      $IF_INVALID_CHOICE
      Activates the text following it if the last song selection was 
      invalid

      $IF_NOT_INVALID_CHOICE
      Activates the text following it if the last song selection was 
      not invalid

      $IF_DUPLICATE_CHOICE
      Activates the text following it if the last song selection was 
      a duplicate choice

      $IF_NOT_DUPLICATE_CHOICE
      Activates the text following it if the last song selection was 
      not a duplicate choice

      $IF_FLAG_1_HI
      Activates the text following it if the specified status flag 
      is high

      $IF_FLAG_1_LO
      Activates the text following it if the specified status flag 
      is low

      $IF_FLAG_2_HI
      Activates the text following it if the specified status flag 
      is high

      $IF_FLAG_2_LO
      Activates the text following it if the specified status flag 
      is low

      $IF_FLAG_3_HI
      Activates the text following it if the specified status flag 
      is high

      $IF_FLAG_3_LO
      Activates the text following it if the specified status flag 
      is low

      $IF_FLAG_4_HI
      Activates the text following it if the specified status flag 
      is high

      $IF_FLAG_4_LO
      Activates the text following it if the specified status flag 
      is low

      $IF_ANY_BUTTON_PRESSED
      Activates the text following it if any button is pressed

      $IF_NOT_ANY_BUTTON_PRESSED
      Activates the text following it if any button is not pressed

      $IF_BUTTON_QUIT_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_QUIT_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_COIN1_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_COIN1_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_COIN2_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_COIN2_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_COIN3_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_COIN3_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_COIN4_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_COIN4_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_VOLUP_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_VOLUP_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_VOLDOWN_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_VOLDOWN_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_RANDOM_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_RANDOM_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_SELECT_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_SELECT_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_SKIP_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_SKIP_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_PAUSE_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_PAUSE_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_UP_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_UP_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_DOWN_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_DOWN_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_LEFT_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_LEFT_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_RIGHT_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_RIGHT_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_LEFT_JUMP_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_LEFT_JUMP_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_RIGHT_JUMP_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_RIGHT_JUMP_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_LEFT_ALPHA_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_LEFT_ALPHA_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_RIGHT_ALPHA_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_RIGHT_ALPHA_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_AUTO_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_AUTO_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_LOOP_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_LOOP_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_FREE_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_FREE_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_CLEAR_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_CLEAR_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_MUTE_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_MUTE_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_0_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_0_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_1_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_1_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_2_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_2_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_3_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_3_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_4_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_4_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_5_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_5_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_6_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_6_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_7_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_7_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_8_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_8_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_9_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_9_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_A_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_A_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_B_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_B_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_C_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_C_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_D_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_D_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_E_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_E_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_F_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_F_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_G_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_G_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_H_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_H_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_I_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_I_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_J_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_J_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_K_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_K_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_POWER_OFF_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_POWER_OFF_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_FLAG_1_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_FLAG_1_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_FLAG_2_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_FLAG_2_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_FLAG_3_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_FLAG_3_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $IF_BUTTON_FLAG_4_PRESSED
      Activates the text following it if the specified button is pressed

      $IF_NOT_BUTTON_FLAG_4_PRESSED
      Activates the text following it if the specified button is not 
      pressed

      $NO_DRAW
      Supresses drawing of the status object

      $END_IF
      Marks the end of a text section playing by the preceding $IF_

    The variables beginning $IF_ and $IF_NOT_ are used to conditionally 
    execute or ignore the text in the config file which follows it, 
    upto the next $END_IF (or end of the line).  Note that IF conditions 
    cannot span lines in the text file.  Variables which do not begin 
    with $IF specify dedicated jukebox status such as song names, 
    etc.  Each status box can also include images for cover art for 
    the currently playing song, and other user defined bitmaps.  
    Any image will be scaled to cover the entire status box.
    
    Hint: For best performance, it is advisable to limit the number 
    of $ variables in a status box.  It is better to group status 
    variables together depending upon when they change; for example 
    try not to mix status which changes regularly (like now playing 
    elapsed time) with status that doesn't change regularly (such 
    as 'coming up' status) in one status box.  This is because the 
    entire contents of a status box is re-drawn if just one element 
    changes.


  8: Status Flags

  Four status flags allow for inter-status communication and user 
  triggered status events.  Each status flag can be set high or 
  low from button presses (toggle) and/or status $variables.  The 
  values of the flags can be read in status objects, allowing support 
  for functionality such as...
  
  1. Inter status communication:
  for example one status object could toggle a flag with a certain 
  timer tick period which could then be detected in a different 
  status object with a different timer tick period. This would 
  allow status to "time-out" after being started from a different 
  timer period (or a button press)
  2. Button invoked status display:
  The flag buttons can be used to turn on and off status information.


  9: GPIO Input/Output

  fruitbox can use the GPIO pins for both input and output:
  
  When a button is defined which uses a GPIO pin, the GPIO pin 
  is automatically configured as an input, with an internal pullup 
  resistor.  You then just have to ensure that the hardware button 
  is connected between this GPIO pin and GND.
  
  When a $SET_GPIO* variable is encountered in a status object 
  Contents file, the specified GPIO pin is automatically configured 
  as an output.
  
  Note that if the same pin is defined in both the button mapping 
  file and a status object, then input will take precedence over 
  the output, hence the status output will not work.
  
  The fruitbox developer assumes no responsibility for any damage 
  caused to the Raspberry Pi or connected hardware due to the use 
  of the GPIO pins from fruitbox, so please make sure you choose 
  your GPIO pin assignments carefully ;)


  10: Input Control Buttons

  The fruitbox input controls can be modified using the a button 
  mapping file ('fruitbox.btn' by default).  If this file exists 
  in the same directory as fruitbox, it will be read by fruitbox 
  to determine one or more button mappings.  See section 'Button 
  Mapping File'.
  
  By default, the buttons are mapped to keyboard keys (see section 
  'Default Buttons'), but each key can be re-mapped to any of the 
  following...
  
  1. Keyboard key
  2. GPIO input pin
  3. USB joystick stick / button
  4. Region on touch screen
  
  The fruitbox command line parameter '--config-buttons' can be 
  used to interactively assign buttons, and generate the button 
  map file.  The btn file can be manually edited later if minor 
  adjustments are required.  The '--test-buttons' command line 
  parameter can be used to check what codes are generated without 
  creating a button mapping file.
  
  For touch screen buttons, the touch areas are defined in the 
  skin file itself, using the [touch areas] section, because these 
  are skin-related.  However, the button assignment to touch input 
  is done in the btn file because this is hardware and not skin 
  related.  Button assignments are not specified in the skin to 
  ensure skins remain compatible with different button hardware 
  setups.


  10.1: Default Buttons

    The button controls are mapped to the following keyboard keys 
    by default, but can be re-mapped to other keyboard keys, GPIO 
    inputs, USB joysticks or touch screen inputs defined in the button 
    mapping file.
    
               LEFT : ButtonLeft ........ Move pages left
              RIGHT : ButtonRight ....... Move pages right
                  [ : ButtonLeftJump .... Move 'PageJump' pages
                  ] : ButtonRightJump ... Move 'PageJump' pages
                  , : ButtonLeftAlpha ... Move to prev sort section*
                  . : ButtonRightAlpha .. Move to next sort section*
                 UP : ButtonUp .......... Move song selection up
                                          (joystick mode only)
               DOWN : ButtonDown ........ Move song selection down
                                          (joystick mode only)
    0 to 9 / A to K : Button0..ButtonK .. Song selection
              ENTER : ButtonSelect ...... Select song
                 F1 : ButtonCoin1 ....... Insert coin
                 F2 : ButtonCoin2 ....... Insert coin
                 F3 : ButtonCoin3 ....... Insert coin
                 F4 : ButtonCoin4 ....... Insert coin
                 F5 : ButtonFlag1 ....... Toggle status flag 1
                 F6 : ButtonFlag2 ....... Toggle status flag 2
                 F7 : ButtonFlag3 ....... Toggle status flag 3
                 F8 : ButtonFlag4 ....... Toggle status flag 4
              SPACE : ButtonRandom ...... Select random song
          BACKSPACE : ButtonSkip ........ Skip (stops currently
                  Z : ButtonPause ....... pause (pauses/unpauses
                                          currently playing song)
                  R : ButtonAuto ........ Toggle Auto Play mode
                  L : ButtonLoop ........ Toggle Loop mode
                  P : ButtonFree ........ Toggle Free Play mode
                  X : ButtonClear ....... Clear all songs in
                                          play queue
                  = : ButtonVol+ ........ Song volume up
                  - : ButtonVol- ........ Song volume down
                  M : ButtonMute ........ Mute / Unmute song and
                                          sound effects volume
                ESC : ButtonQuit ........ Quit fruitbox
                F12 : ButtonPowerOff .... Power off Raspberry Pi
    
    * The sort sections start with a new letter of the alphabet 
    corresponding to the last SortSongsBy value.  For example, if 
    the last SortSongsBy = Artist, and the currently displayed artists 
    begin with 'B', then pressing ButtonLeftAlpha will move to page 
    which contains the first Artist beginning with the letter 'A'.


  10.2: Button Mapping File

    The button mapping file ('fruitbox.btn' by default, or specified 
    by the --button-map command line option) contains data in the 
    same format as the skin configuration files.  Each entry specifies 
    a button and its source and parameters.  This file can be automatically 
    generated by the '--config-buttons' command line parameter, and 
    then edited later if adjustments are needed.
    
    If the button file does not exist in the same directory as fruitbox, 
    then all buttons will adopt their default mappings.  Any buttons 
    not defined in the button file will adopt their default mapping.
    
    The following entries in the button file are recognised:


    
    Each of the above Button* parameters can be assigned one of the 
    following values...
    
     = Keyboard <code>
     = GPIO <number>
     = Touch <id>
     = Joystick <id> <axis> <position>
    The above <code>, <number>, <id>, <axis> and <position> values 
    can be determined by fruitbox using the '--config-buttons' or 
    '--test-buttons' command line options.


  11: Troubleshooting

  Poor graphics performance is usually caused by not allocating 
  enough memory to the GPU.  If the display is very sluggish, or 
  is corrupted / flashing white, quit fruitbox and check for any 
  'GetError_0x505' messages.  These messages mean the GPU hasn't 
  got enough memory to create the graphics in video memory, so 
  has to use (slower) CPU memory instead.  To fix this, change 
  the Raspberry Pi memory split using the Advanced Options in the 
  raspi-config (type 'sudo raspi-config' from the command line). 
  256M is recommended for the GPU, but more may be needed if the 
  skin contains lots of large graphics objects.


  12: Hints and Tips

  Automatically run fruitbox on power up
  --------------------------------------
  
  To run fruitbox automatically on power up, add the following 
  lines to ~/.bashrc :
  
   cd <directory where fruitbox is installed>
   sudo ./fruitbox --cfg <your cfg file>
  
  
  Automatically mount USB memory stick on power up
  ------------------------------------------------
  
  If your music is stored on a USB memory stick, you can automatically 
  mount the USB memory stick at boot time by typing the following 
  commands:
  
   sudo mkdir -p /mnt/usb
   sudo nano /etc/fstab
  
  When inside the nano editor, add the following line at the end 
  of the table...
  
  /dev/sda1     /mnt/usb       vfat    defaults    0       0
  
  Save (Ctrl-O), then Quit nano (Ctrl-X).  Then in your fruitbox 
  configuration file, set the 'MusicPath' parameter to '/mnt/usb/'
  
  
  Animated GIF support
  --------------------
  
  Animated GIF files can be supported by splitting the GIF file 
  into individual files (by using 'ffmpeg -i file.gif file%02d.jpg' 
  for example), including them in a [status] section with multiple 
  'Bitmap' entries, and specifying the animation speed with 'TimerTickPeriod'. 
  Then in your status Contents text file include the text
  '$IF_TIMER_TICK$DRAW_BITMAP'.
  
  
  Animated Touchscreen Buttons
  ----------------------------
  
  Configuring buttons for touch input will only cause a button 
  event to be generated if the touch screen is touched in the area 
  of the button defined in the skin file [touch areas]; it won't 
  produce any visual effects.  In order to produce an effect of 
  the button being pressed visually, you can define a status object 
  which displays an image of the depressed button if the button 
  press event has occurred i.e. in the status Contents file you 
  will need the text:
   $IF_BUTTON_LEFT_PRESSED$DRAW_BITMAP$END_IF
   $IF_NOT_BUTTON_LEFT_PRESSED$UNDRAW_BITMAP$END_IF
  for example when pressing ButtonLeft.  If the status object is 
  placed over a image of an unpressed button (i.e. in the background) 
  then this will have the desired effect.
  
  
  Quick fruitbox style change using USB memory sticks
  ---------------------------------------------------
  
  As a general tip, you can store the configuration file and database 
  file on a USB memory stick along with the music, and run fruitbox 
  using the command 'sudo ./fruitbox --cfg /mnt/usb/fruitbox.cfg'. 
  That way, you could have a complete jukebox look and feel with 
  specific music all self-contained on the USB stick, so then all 
  you need to do to change jukebox styles and music collections 
  is to swap USB sticks...
  
  Let's Rock!


To encourage future development, please consider making a donation
to the author at https://paypal.me/rpifruitbox
